# 1NF: 符合1NF的关系中的每个属性都不可以再分.
- 1NF是所有关系型数据库的最基本要求.
- 存在数据冗余过大,插入异常,删除异常,修改异常

# 2NF: 在1NF的基础上,消除了非主属性对于码的部分函数依赖.
1. 函数依赖
	
	在一张表中,属性(或属性组)X的值确定的情况下,必定能够确定属性Y的值,那么就说Y函数依赖于X,写作 X->Y.
2. 完全函数依赖
	
	在一张表中,若 X->Y ,且对于X的任何一个真子集(假如属性组X包含超过一个属性), X->Y 不成立,那么我们称Y对于X完全函数依赖.记作 X$\xrightarrow{\text{F}}$Y
3. 部分函数依赖
	
	假如Y函数依赖于X,但同时Y并不完全依赖于X,那么我们就称Y部分依赖于X.记作 X$\xrightarrow{\text{P}}$Y
4. 传递函数依赖
	
	加入Z函数依赖于Y,且Y函数依赖于X(Y不包含X,且X不函数依赖于Y),那么我们称Z传递函数依赖于X,记作 X$\xrightarrow{\text{T}}$Z.	

### 码
- 假设K为某表中的一个属性或者属性组,若K之外的所有属性都完全依赖于K,那么我们称K为候选码.
- 可以理解为: 假如当K确定的情况下,该表除K之外的所有属性的值也都随之确定,那么K就是码.
- 一张表中可以有超过一个码.

### 非主属性
包含在任何一个码中的属性称之为主属性. 其他的为非主属性.


## 判断是否是2NF

1. 找出数据表中所有的码
2. 根据第一步得到的码,找出所有的主属性
3. 数据表中,除去主属性,剩下的就是非主属性了
4. 检查是否存在非主属性对码的部分函数依赖

> 就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“完全函数依赖”）。

改进了:

1. 数据冗余
2. 修改异常

问题:

1. 插入异常
2. 删除异常

		
# 3NF: 在2NF的基础上,消除了非主属性对于码的传递函数依赖.

> 符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。

# BCNF: 在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。

